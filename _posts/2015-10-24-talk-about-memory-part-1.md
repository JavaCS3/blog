---
layout: post
category: linux
title: 内存解析（一）：内存类型（译）
---

## 前言
本系列文章主要翻译自[techtalk.intersec.com](https://techtalk.intersec.com/2013/07/memory-part-1-memory-types/)。目的在于帮助大家更好的理解现代计算机的内存管理知识。如有翻译不到位的地方还请指正。

## 简介
在Intersec，我们选择C语言作为编程语言是因为它有很强的操控性和很高的性能。对很多人而言，性能只不过是尽可能的少用几个CPU指令。然而，在现代硬件体系下，复杂的东西不仅仅是CPU。它还包括算法需要消耗的内存，CPU，磁盘，网络I/O等等。以上每一例都增加了算法的开销并且为了保证算法的性能以及可靠性，你必须正确的理解以上每一例。

正如磁盘性能和网络延迟一样，影响CPU性能（算法复杂度）的因素是很好理解的。但是对于内存，我们似乎对它了解的不多。根据我们的经验与我们的客户显示，即使是像`top`这样如此常见的工具对于大多是系统管理员来还是很神秘。

此文是本系列的第一篇。我们将会详细的探讨诸如内存的定义、内存是如何管理的、如何去解读一些工具的输出内容... 本系列教程将受众于开发人员和系统管理员。尽管大多数的规则应同样适用于现代的操作系统，我们仍选择详细的探讨Linux和C语言编程。

我们虽不是第一个写有关内存方面文章的人。但在此，我们想特别强调一下Ulricht Drepper写的一篇高质量的文献[《What every programmer should know about memory》](http://www.akkadia.org/drepper/cpumemory.pdf)。

本文将阐明内存的定义。本文假设读者已经具备了诸如地址和进程的基本知识。本文会经常探讨诸如系统调用（system calls）、用户态（user-land）与内核态（kernel mode）之间的区别。然而，你需要知道的是你的进程（用户态）是如何通过内核跟硬件打交道的并且系统调用可以使你的进程通过内核而请求更多的资源。你可以阅读帮助文档来了解系统调用的细节知识。

## 虚拟内存（Virtual Memory）
在现代操作系统中，每个进程都运行在自己的内存分配空间内。操作系统除了需要将内存地址直接映射到硬件地址之外，操作系统还充当一个硬件抽象层并且为每个进程创建虚拟内存空间（virtual memory space）。

