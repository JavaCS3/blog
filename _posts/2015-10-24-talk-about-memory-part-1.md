---
layout: post
category: linux
title: 内存解析（一）：内存类型（译）
---

## 前言
本系列文章主要翻译自[techtalk.intersec.com](https://techtalk.intersec.com/2013/07/memory-part-1-memory-types/)。目的在于帮助大家更好的理解现代计算机的内存管理知识。如有翻译不到位的地方还请指正。

## 简介
在Intersec，我们选择C语言作为编程语言是因为它有很强的操控性和很高的性能。对很多人而言，性能只不过是尽可能的少用几个CPU指令。然而，在现代硬件体系下，复杂的东西不仅仅是CPU。它还包括算法需要消耗的内存，CPU，磁盘，网络I/O等等。以上每一例都增加了算法的开销并且为了保证算法的性能以及可靠性，你必须正确的理解以上每一例。

正如磁盘性能和网络延迟一样，影响CPU性能（算法复杂度）的因素是很好理解的。但是对于内存，我们似乎对它了解的不多。根据我们的经验与我们的客户显示，即使是像`top`这样如此常见的工具对于大多是系统管理员来还是很神秘。

此文是本系列的第一篇。我们将会详细的探讨诸如内存的定义、内存是如何管理的、如何去解读一些工具的输出内容... 本系列教程将受众于开发人员和系统管理员。尽管大多数的规则应同样适用于现代的操作系统，我们仍选择详细的探讨Linux和C语言编程。

我们虽不是第一个写有关内存方面文章的人。但在此，我们想特别强调一下Ulricht Drepper写的一篇高质量的文献[《What every programmer should know about memory》](http://www.akkadia.org/drepper/cpumemory.pdf)。

本文将阐明内存的定义。本文假设读者已经具备了诸如地址和进程的基本知识。本文会经常探讨诸如系统调用（system calls）、用户态（user-land）与内核态（kernel mode）之间的区别。然而，你需要知道的是你的进程（用户态）是如何通过内核跟硬件打交道的并且系统调用可以使你的进程通过内核而请求更多的资源。你可以阅读帮助文档来了解系统调用的细节知识。

## 虚拟内存（Virtual Memory）
在现代操作系统中，每个进程都运行在自己的内存分配空间内。操作系统除了需要将内存地址直接映射到硬件地址之外，操作系统还充当一个硬件抽象层并且为每个进程创建虚拟内存空间（virtual memory space）。CPU利用内核维护的每进程转换表（translation table）来控制物理内存地址和虚拟地址之间的映射关系（每次内核切换某一CPU核上的运行进程时只需改变该CPU核上的转换表即可）。

虚拟内存有许多的用意。首先，它可以使进程彼此独立。一个用户进程只能通过虚拟内存对内存访问。因此，它只能访问之前已经映射到自己虚内存空间的数据，它也不能访问其他进程的内存（除非显示指明为共享的）。

第二个意图是虚拟内存提供了硬件的抽象关系。内核可以自由的改变虚拟地址所映射的物理地址。它同样可以不提供物理地址给虚拟地址直到真正需要的时候才提供。甚至它可以在系统缺少物理内存的时候将长时间不用的内存交换到磁盘中。这总体上给了内核许多的自由，唯一的限制是当程序在读内存的时候它实际上是在找之前写在上面的内容。



