---
layout: post
category: linux
title: 内存解析（一）：内存类型（译）
---

## 前言
本系列文章主要翻译自[techtalk.intersec.com](https://techtalk.intersec.com/2013/07/memory-part-1-memory-types/)。目的在于帮助大家更好的理解现代计算机的内存管理知识。如有翻译不到位的地方还请指正。

## 简介
在Intersec，我们选择C语言作为编程语言是因为它有很强的操控性和很高的性能。对很多人而言，性能只不过是尽可能的少用几个CPU指令。然而，在现代硬件体系下，复杂的东西不仅仅是CPU。它还包括算法需要消耗的内存，CPU，磁盘，网络I/O等等。以上每一例都增加了算法的开销并且为了保证算法的性能以及可靠性，你必须正确的理解以上每一例。

正如磁盘性能和网络延迟一样，影响CPU性能（算法复杂度）的因素是很好理解的。但是对于内存，我们似乎对它了解的不多。根据我们的经验与我们的客户显示，即使是像`top`这样如此常见的工具对于大多是系统管理员来还是很神秘。

此文是本系列的第一篇。我们将会详细的探讨诸如内存的定义、内存是如何管理的、如何去解读一些工具的输出内容... 本系列教程将受众于开发人员和系统管理员。尽管大多数的规则应同样适用于现代的操作系统，我们仍选择详细的探讨Linux和C语言编程。

我们虽不是第一个写有关内存方面文章的人。但在此，我们想特别强调一下Ulricht Drepper写的一篇高质量的文献[《What every programmer should know about memory》](http://www.akkadia.org/drepper/cpumemory.pdf)。

本文将阐明内存的定义。本文假设读者已经具备了诸如地址和进程的基本知识。本文会经常探讨诸如系统调用（system calls）、用户态（user-land）与内核态（kernel mode）之间的区别。然而，你需要知道的是你的进程（用户态）是如何通过内核跟硬件打交道的并且系统调用可以使你的进程通过内核而请求更多的资源。你可以阅读帮助文档来了解系统调用的细节知识。

## 虚拟内存（Virtual Memory）
在现代操作系统中，每个进程都运行在自己的内存分配空间内。操作系统除了需要将内存地址直接映射到硬件地址之外，操作系统还充当一个硬件抽象层并且为每个进程创建虚拟内存空间（virtual memory space）。CPU利用内核维护的每进程转换表（translation table）来控制物理内存地址和虚拟地址之间的映射关系（每次内核切换某一CPU核上的运行进程时只需改变该CPU核上的转换表即可）。

虚拟内存有许多的目的。首先，它可以使进程彼此独立。一个用户进程只能通过虚拟内存对内存访问。因此，它只能访问之前已经映射到自己虚内存空间的数据，它也不能访问其他进程的内存（除非显示指明为共享的）。

第二个目的是提供硬件的抽象关系。内核可以自由的改变虚拟地址所映射的物理地址。它同样可以不提供物理地址给虚拟地址直到真正需要的时候才提供。甚至它可以在系统缺少物理内存的时候将长时间不用的内存交换到磁盘中。这总体上给了内核许多的自由，唯一的限制是当程序在读内存的时候它实际上是在找之前写在上面的内容。

第三个目的是给不在RAM中的内容提供地址。这是`mmap`和文件映射的实现原理。你可以为一个文件提供一个虚拟内存地址从而使文件的访问如同访问内存缓冲区（memory buffer）一样。这是一个可以使代码保持简单的有用的抽象方法。由于64位机器有巨大的虚拟地址空间，你甚至可以把整个硬盘映射到虚拟内存当中。

第四个目的是为了共享（sharing）。既然内核知道每个运行进程的虚拟空间映射关系，那么内核就可以避免两次载入相同的东西并且使利用相同资源进程的虚拟地址指向同一块物理空间（即便每个虚拟地址是进程独立的）。内核通过写拷贝（copy-on-write: COW）的方式实现共享：当两个进程使用同一片数据但其中一个进程修改了该数据而另一个进程是看不到修改的，内核只有在数据修改的时候才会拷贝。近期，操作系统也具备了在几个地址空间内识别特定内存并自动将其映射到同一物理内存的能力，在Linux上叫做[KSM（Kernel SamePage Merging）](http://en.wikipedia.org/wiki/Kernel_SamePage_Merging_(KSM))。

    fork()

利用COW技术的典型代表就属`fork()`。在Unix-like系统中，`fork()`是一个复制自身进程来创建进程的系统调用。当`fork()`返回时，每个进程都将从同一个位置继续执行，并且具有相同打开的文件和相同的内存。多亏了COW技术，`fork()`并不会在fork的时候立刻复制内存，只有当数据修改的时候才会在RAM中复制内存无论是被父进程还是子进程。由于大部分使用`fork()`之后都会紧接着调用`exec()`来使整个虚拟内存地址空间无效，COW机制避免了无意义的父进程的内存拷贝。
